\documentclass{article}
\usepackage{amsmath,amssymb,xcolor}
\usepackage[utf8]{inputenc}
\usepackage[colorlinks]{hyperref}
\usepackage{minted}

\title{Javascript in 7 Minutes: A Guide for 2024}
\author{thegoldenmule}
\frenchspacing
\begin{document}\maketitle\tableofcontents

\newpage
\section{Introductory Laments}

This shouldn't need to exist yet here I am, writing it. Please lament with me. This guide is purely pragmatic. It is not entirely accurate, and in the future, much like learning anything, you may need to unlearn a bit. It is intended for students that have an assignment due fifteen minutes from now but forgot to learn Javascript. Perhaps you, dear reader, are in class \textit{right now} and you're trying to catch up on something you saw on the board.
\\
\\
Have no fear, you'll be productive in seven minutes. Assignment done in fourteen.

\section{Quick Facts}

Quickly now, Javascript:\\

\begin{itemize}
	\item ...runs on a \textit{javascript runtime}, which may compile to bytecode, machine code, or run as a simple interpreter. The runtime usually runs in a browser or on a server, but plenty of runtimes are put other places.
	\item ...is \textit{weakly} typed, meaning the language tries to automatically coerce types into other types instead of just failing (eg - it tries to make strings into ints for you).
	\item ...is also \textit{dynamically} typed, meaning type information is determined while it's running, and heck, you can even change types midway through.
	\item ...has \textit{historical issues} to watch out for, but is generally safe and fun to use in modern form.
	\item ...has great documentation on MDN (Mozilla Developer Network). There is no better reference.
\end{itemize}

\section{Variables}

Variables in Javascript are written differently depending on whether or not they are \textbf{mutable}, i.e. whether or not they can be changed. Get in the habit of always starting with variables that are \textbf{immutable}, or don't change.
\\
\begin{minted}{javascript}
// define an immutable (unchangeable) variable
const myVariable = 5;

// define a mutable (changeable) variable
let myMut = "hello";
\end{minted}

\noindent
\\
Never, God help you, under any circumstances define variables in these ways:
\\
\begin{minted}{javascript}
foo = 5;

var bar = 6;
\end{minted}

\noindent
\\
These are syntactically correct, but can easily create global variables (which, as we all know, are almost-categorically bad).

\section{Types}

As stated before, Javascript is weakly typed. This means that the runtime will try to \textit{coerce} types for you automatically. In many languages, these examples will fail to compile, but in Javascript they may give completely nonsensical results:

\begin{minted}{javascript}
const sum = 3 + "4"; // "34"
const wat = [] + 1; // "1"
\end{minted}

\noindent
\\
In addition, the equality operator, \textbf{==}, is very hard to use.

\begin{minted}{javascript}
true == "true"; // false
3 == "3"; // true
undefined == null; // true
\end{minted}

\noindent
\\
In general, just don't use $==$ at all! Instead, use "strict equality", $===$, which usually matches expectations much better.

\begin{minted}{javascript}
true === "true"; // false
3 ===  "3"; // false
undefined === null; // false
\end{minted}

\noindent
\\
Types fall in two categories: \textbf{primitives} or \textbf{objects}. There are \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_overview#data_types}{seven primitives}, but here are the ones you should know how to use right now:
\begin{minted}{javascript}
// number (there are no integers or fixed points, only floats)
const num = 5.4;

// strings (there are no chars -- strings only)
const str = "I am a string";

// boolean
const bool = true; // or false, obviously

// undefined
let bar = undefined;

// null
let fizz = null;
\end{minted}

\noindent
Note that the \textbf{null} and \textbf{undefined} data types are not the same. Variables that have been declared but not initialized are undefined.

\begin{minted}{javascript}

let a;

// a === undefined

a = 4;

// a === 4

\end{minted}

\noindent
\\
Everything that is not a primitive is an \textbf{Object}, including \textbf{Function} and \textbf{Array}.

\section{Objects}

A Javascript \textbf{Object} is very similar to an associative array, map, or dictionary in other languages. Any type can act as a key.

\begin{minted}{javascript}
const myObject = {
	counter: 0,
	foo: () => console.log("foo"),
	5: 6,
	"fizz": "buzz",
};
\end{minted}

\noindent
\\
Note that, while the \textit{myObject} reference is const, the object itself can be manipulated.

\begin{minted}{javascript}
// perfectly legal
myObject.bar = true;

// throws error
myObject = {};
\end{minted}

\noindent
\\
Furthermore, we can access things in an object in multiple ways:

\begin{minted}{javascript}
myObject.counter; // 0

myObject["counter"]; // 0

const key = "counter";
myObject[key]; // 0
\end{minted}

\section{Functions}

A mathematical function usually looks something like this:
\\
\begin{equation}
\textbf{f}(x):\mathbb{R}\rightarrow\mathbb{R}
\end{equation}
\\
This defines the function, called \textbf{f}, that takes a real number ($\mathbb{R}$), called x, and returns a real number. (1) is a \textit{different function} than this one:
\\
\begin{equation}
\textbf{g}(x):\mathbb{R}\rightarrow\mathbb{N}
\end{equation}
\\
Not just because the name is different, but because this one returns a natural number ($\mathbb{N}$).
\\
\\
In Javascript, functions are written like this:
\\
\begin{minted}{javascript}
const sum = (a, b) => {
	return a + b;
};
\end{minted}

\noindent
\\
This defines the function \textbf{sum} that takes two parameters, \textbf{a} and \textbf{b}, and returns their sum. The block \{\} and \textbf{return} statement can be removed if the function is a single line long.
\\
\begin{minted}{javascript}
const sum = (a, b) => a + b;
\end{minted}
\noindent
\\
Since Functions are just objects, they too act like associative arrays, and can be passed around just like anything else.
\\
\begin{minted}{javascript}
const foo = () => 3;
foo.wat = "bar";

const bar = () => 4;

// this is absurd, but valid
bar[foo] = "no";

// functions can be passed as arguments
const c = (a, b) => a() + b();
c(foo, bar);
\end{minted}

\section{Arrays}

In Javascript, arrays are implemented like \textbf{doubly linked lists}. Remember those? You can insert in front, push onto the end, pop things off, pull things out of the middle, and change the length dynamically. This means that Javascript Arrays can also be queues, stacks, and more.

\noindent
\\
Arrays are usually created using an "array literal", which looks like [ ], with zero or more items inside.
\\

\begin{minted}{javascript}
// create an array
const arr = [];

console.log(arr.length); // 0

arr.push(1); // [1]

arr.splice(0, 0, "start"); // ["start", 1]

arr.splice(0, 1); // [1]

// this creates a new array
const newArr = arr.concat([2, 3]); // [1, 2, 3]

\end{minted}

\noindent
\\
Arrays have many useful, powerful methods on them that can be used to do things quickly.

\begin{minted}{javascript}
// iterate
[1, 2, 3].forEach(i => console.log(i));

// transform
[1, 2, 3].map(i => i + 1); // [2, 3, 4]

// conditions
[1, 2, 3].every(i => i > 2); // false
[1, 2, 3].some(i => i > 2); // true

// flatten
[1, [2, 3, [4, 5]]].flat(Infinity); // [1, 2, 3, 4, 5]
\end{minted}

\section{Classes}

Javascript is \textbf{not} a classical language. This does not mean that javascript cannot play violin, it means that it doesn't have "classical inheritance". C++, C\#, Java -- these languages encourage you to define "classes" and then create "instances" of classes. Classes are the means to share functionality or shape.

\begin{minted}{javascript}

// C# Example
class MyClass {
	public int Foo;
}

...

// now create an instance
MyClass instance = new MyClass();
\end{minted}

\noindent
\\
Javascript does not work the same way. While the \textbf{new} operator does exist (as does \textbf{class}), it doesn't work the same way. Javascript uses "prototypal inheritance", which is fundamentally different and generally considered "trickier". This guide does not describe Javascript classes, other than to avoid their use entirely.

\section{Conclusion}

The seven minute hourglass is almost empty, and here we are. You should now know Javascript as well as 90\% of professional Javascript developers. GLHF.

\end{document}

















